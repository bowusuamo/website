Our final project was largely inspired by the flask app we designed in Finance pset in that we utilized a lightweight web application framework for our program. The original idea was to import an API key that contianed SQL tables that included colleges and the average SAT, ACT, and GPA scores of the students that had been accepted. However, it took us a while to print the values in the API key that we imported, and then we realized that the information was not extensive enough, so we looked for other API keys for a while. At a certain point we decided that it would be a better use of our time to create a data base of our own, and since we would not be able to get all of the data for all colleges and manually put it into a SQL table, we decided to focus on data from one college: Harvard.
Our final project was largely inspired by the flask app we designed in Finance pset in that we utilized a lightweight web application framework for our program. The original idea was to import an API key that contianed SQL tables that included colleges and the average SAT, ACT, and GPA scores of the students that had been accepted. However, it took us a while to print the values in the API key that we imported, and then we realized that the information was not extensive enough, so we looked for other API keys for a while. At a certain point we decided that it would be a better use of our time to create a data base of our own, and since we would not be able to get all of the data for all colleges and manually put it into a SQL table, we decided to focus on data from one college: Harvard.

Because our web app required much of the same features and functions as finance, we first imported the needed packages and configured our flask app. Knowing we would need we would need to access and store data, we configured a SQLite database (college.db) and hard coded the data via importing a google sheets .csv file into college.db 

After setting up the flask app, we need to set up the app routes to map the specific URLs with the associated functions to perform the desired tasks. Some HTML pages required declaration of methods to enable communication between clients and servers through forms. Pages that only utilized HTTP GET method only retrieved data from a specified resource; whereas, other pages utlized both GET and POST method to not only retrieve data but also  send data to a server to create/update a resource. 

Implementing a SQLite database was an integral part of this program in that we created two tables; a users table tracked profiles created and associating data (id, username, hash, SAT, ACT, GPA) as well as a statitstic table to track the associating data for current Harvard student college admission statistics (SAT, ACT, GPA). An instance wherein new data needed to be inserted into the database would be that of new account registrations. Utilizing forms, users were able to input data about themselves (desired username, password and SAT, ACT, GPA). Using a SQL execute statement, we are able to insert new data into the desired table with given parameters. Similarly, we were able to also update data in an existing table by execute a SQL statment that queries into the desired location in a table and change the data to whatever indicated in form by user (update function). The last way SQL queries were utilized in this project was by way of retrieving information. For instance, when informing users of how their stats compare to that of current Harvard students, our program queries into the statistics table to retrieve the desired stat types and performs a calculation and returns comparison for users. 

While the python source code and SQL database made up the backend, HTML and CSS were incorporated into this project to build and design the frontend of the program. HTML code was used to structure a web pages and their content. HTML code allows web pages to have text, buttons, images, etc. Additionally, HTML class attributes allow us to associate different HTML tags together so that we are able to change characterstics of elements on the page cohesively with a stylesheet. Stylesheets are written with CSS and allowed us to move and modify elements as desired. A convenient aspect about web development we took full advantage of was the existing HTMl and CSS template out there such as boostrap docs. This allowed us to implement interesting and otherwise complicated elements and designs such as image carousels, buttons, forms, etc. Another feature of our HTML pages was the use of page extensions {% extends "layout.html" %} in which we created the layout.html as a template for all the web pages so as to not have to rewrite repetitive code to reimport necessary packages and build consistent elements such as the navigation bar and login/register button.  

Complications:
The update function took a while for us to understand because our initial plan was to update users WHERE the username was the username that the user inputted, but instead of updating the already existing row in the SQl table, our function created a new row in the SQL table. While a user is able to change their profile information, our update function does not allow for the user to change data and keep the same username. The beginning of our update function is similar to register and login. The key part that we needed was to create a variable for the user_id as is seen in line 161. Then we update the username, SAT, ACT, GPA, for the user made on the session id which changed the information for the user instead of creating another user. Our matches function selects the GPA, SAT, and ACT scores that the user inputed that are in the SQL table using SQL queries and indexing where appropriate, and counts the amount of times that those values are found in the in the statistics table using SQL quesries and indexing. Then the function finds the percentage of the total amount of students in the data table that have those statistics and returns them to be put on the matched HTML page using jinja. The aboutus and contact functions return the html pages for the respective functions.